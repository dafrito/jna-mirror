<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">
<html>
<head>
<!-- 
  Copyright 2007 Timothy Wall
-->
</head>

<HR>
<CENTER>
<H1>Java Native Access</H1>
</CENTER>
<body bgcolor="white">
This document is the API specification for the
<a href=http://jna.dev.java.net>JNA</a>
library for simplified native library access for Java.
<p>
<a href=#navbar_top>Top</a>&nbsp;
<a href=http://jna.dev.java.net>JNA Home</a>&nbsp;
<a href=index.html target=_top>API w/FRAMES</a>&nbsp;
<p>

<a name="overview"></a>
<h1>Java Native Access (JNA)</h1>
JNA provides simplified access to native library methods without requiring any
additional JNI or native code.
<p>

<h2>Library Mapping</h2>
When you've determined which shared library holds the methods to which you
need access, create an interface class corresponding to that library.  For
example, a mapping for the C library itself would look like this:<br>
<blockquote><code><pre>
public interface CLibrary extends Library {
    CLibrary INSTANCE = (CLibrary)Native.loadLibrary("c", CLibrary.class);
}
</pre></code></blockquote>
The <code>String</code> passed to the <code>Native.loadLibrary</code> method
is the undecorated name of the shared library file.  Here are some examples of
library name mappings.<p>  
<center><table style="background-color: #EAEAEA;" width="50%">
<tr><td><b>OS</b></td><td><b>Library Name</b></td><td><b>String</b></td></tr>
<tr><td>Windows</td><td>user32.dll</td><td>user32</td></tr>
<tr><td>Linux</td><td>libX11.so</td><td>X11</td></tr>
<tr><td>Mac OS X</td><td>libm.dylib</td><td>m</td></tr>
</table></center>
<p>
Any given native library with a unique filesystem path is represented by a single instance of {@link com.sun.jna.NativeLibrary} and obtained via {@link com.sun.jna.NativeLibrary#getInstance(String)}.  The native library will be unloaded when no longer referenced by any Java code.

<h2>Function Mapping</h2>
Function names are mapped directly from their Java interface name to the
symbol exported by the native library.  For instance, the function to convert
an ASCII string into an integer would look like this:<br>
<blockquote><code><pre>
public interface CLibrary extends Library {
    int atol(String s);
}
</pre></code></blockquote>
If you prefer to rename the Java methods to conform to Java coding conventions, then you can provide an entry ({@link com.sun.jna.Library#OPTION_FUNCTION_MAPPER}/{@link com.sun.jna.FunctionMapper}) in the options <code>Map</code> passed to <code>Native.loadLibrary</code> which maps the Java names to the native names.  While this keeps your Java code a little cleaner, the additional mapping of names may make it a little less obvious the native functions being called.<p>
An instance of the {@link com.sun.jna.Function} class is obtained through the {@link com.sun.jna.NativeLibrary} instance corresponding to the containing native library.  This {@link com.sun.jna.Function} instance handles argument marshalling and delegation to the native function. 

<a name="marshalling"></a>
<h2>Function Argument Mapping (Java to Native Type Conversions, or Marshalling/Unmarshalling)</h2>
Java types are chosen to match native types of the same size.  These are the
default type mappings:<p>
<center><table style="background-color: #EAEAEA;">
<tr><td><b>Native Type</b></td><td><b>Java Type</b></td></tr>
<tr><td>int (boolean)</td><td><i>boolean</i> (mapping can be customized)</td>
<tr><td>char</td><td><b>byte</b></td>
<tr><td>char*</td><td><i>String</i></td>
<tr><td>wchar_t</td><td><b>char</b></td>
<tr><td>wchar_t*</td><td><i>{@link com.sun.jna.WString}</i></td>
<tr><td>short</td><td><b>short</b></td>
<tr><td>int</td><td><b>int</b></td>
<tr><td>long</td><td><i>{@link com.sun.jna.NativeLong}</i></td>
<tr><td>long long</td><td><b>long</b></td>
<tr><td>float</td><td><b>float</b></td>
<tr><td>double</td><td><b>double</b></td>
<tr><td>pointer (array of primitive type as pointer)</td><td><b>&lt;T&gt;[]</b> or <b>{@link java.nio.ByteBuffer}</b></td>
<tr><td>pointer (to type)</td><td><i>{@link com.sun.jna.ptr.ByReference}</i></td>
<tr><td>struct* (pointer to struct)</td><td><i>{@link com.sun.jna.Structure}</i></td>
<tr><td>union*</td><td><i>{@link com.sun.jna.Union}</i></td>
<tr><td>struct[] (array of structs contiguous in memory)</td><td><i>{@link com.sun.jna.Structure}[]</i></td>
<tr><td>primitive arrays within a struct</td><td><b>&lt;T&gt;[]</b> (Array of primitive type)</td>
<tr><td>struct within a struct</td><td><i>{@link com.sun.jna.Structure}</i></td>
<tr><td colspan=2><i>not yet implemented</i></td>
<tr><td>bitfields</td>
<tr><td>struct by value (argument or return value)</td>
</table>
</center>
<p>
Only the Java types indicated in bold are handled directly in native code.
All other types must eventually be converted to one of these basic types.
Those Java types in italics are handled by the JNA Java library and converted
to or from one of the basic types.
<p>
Type mapping behavior may be customized by providing a {@link com.sun.jna.TypeMapper} for the {@link com.sun.jna.Library#OPTION_TYPE_MAPPER} option when initializing a library interface.  See {@link com.sun.jna.win32.W32APITypeMapper} for an example which provides custom conversion of boolean and String types.  You are free to use whatever types are convenient in your defined interfaces, but all custom types <em>must</em> provide a mapping to one of the basic or derived types listed above.
<p>
Type mapping may also be customized on a per-class basis for user-defined types by making the user-defined type implement the {@link com.sun.jna.NativeMapped} interface.  

<h3>Pointers</h3>
Pointers may be used as an opaque type from which other data types may be extracted.  The user is generally not allowed to construct a Pointer de novo. 
<p>
Type-safe pointers may be defined by deriving from the {@link com.sun.jna.PointerType} class.  Any such user-defined type will be treated the same as a {@link com.sun.jna.Pointer}.

<h3>Strings</h3>
Java <code>String</code>s perform the same function as the native types
<code>const char*</code> and <code>const wchar_t*</code>
(<code>NUL</code>-terminated arrays).  In order to use the proper type when
calling a native function, we have to introduce some sort of annotation to
identify how the java  <code>String</code> should be converted.

Java <code>String</code>s are normally converted to <code>char*</code>
since this is the most common usage of strings.  Strings are automatically
converted to a <code>NUL</code>-terminated array of <code>char</code> across
the function call.  Returned <code>char*</code> values are automatically
copied into a <code>String</code> if the method signature returns
<code>String</code> (<code>strdup</code>, for example).
<p>
If the native method returns char* and actually allocates
memory, a return type of {@link com.sun.jna.Pointer} should be used to avoid
leaking the memory.  It is then up to you to take the necessary steps to free
the allocated memory.
<p>
When converting Java unicode characters into an array of <code>char</code>,
the default platform encoding is used, unless the system property
<code>jna.encoding</code> is set to a valid encoding.  This property may be
set to "UTF8", for example, to ensure all native strings use that encoding.
<p>

<h3>Wide Strings</h3>
The {@link com.sun.jna.WString} class is used to identify wide character
strings, and only requires a little effort to obtain a
<code>String</code>.  
<p>

<h3>Buffers/Memory Blocks</h3>
Use arrays to represent buffers of primitive types.  A native method cannot
return a Java array, since there is no canonical way to indicate the intended
length of the returned array.  Instead, use one of the array access methods in
the Pointer class, supplying the length of the returned array.<p>
{@link java.nio.Buffer}s may also be used as a memory buffer input
argument; direct byte buffers can often provide much improved performance over
primitive arrays. 
<p>
If you need to pass in a subset of a primitive array, you can do so by
wrapping it in a {@link java.nio.Buffer} subclass, such as {@link
java.nio.ByteBuffer}, using the {@link
java.nio.ByteBuffer#wrap(byte[],int,int)} method.  Wrapping an array in a
buffer also allows you to pass only a subset of a Java array to the native
function. 

<h3>Callbacks (Function Pointers)</h3>
JNA supports supplying Java callbacks to native code.  You must define an
interface that extends the {@link com.sun.jna.Callback} interface, and define
a single <code>callback</code> method with a signature that matches the
function pointer required by the native code.  The name of the method
<em>must</em> be "callback", and the arguments and return value follow the
same rules as for a direct function invocation.
<p>
If your native code initializes function pointers within a struct, JNA will
automatically generate an <code>Callback</code> instance matching the declared
type.  This enables you to easily call the function supplied by native code
using proper Java syntax.
<blockquote><code><pre>
// C code
struct _functions {
  int (*open)(const char*,int);
  int (*close)(int);
};

// Java
public class Functions extends Structure {
  public static interface OpenFunc extends Callback {
    int callback(String name, int options);
  }
  public static interface CloseFunc extends Callback {
    int callback(int fd);
  }
  public OpenFunc open;
  public CloseFunc close;
}
...
Functions funcs = new Functions();
lib.init(funcs);
int fd = funcs.open.callback("myfile", 0);
funcs.close.callback(fd);
</pre></code></blockquote>

<h3>Structures</h3>

<h4>Pointer-to-Structure Arguments</h4>
To pass a pointer to a structure as an argument, simply use the Java structure
subclass, and a pointer to native data memory will be used.  The contents of
the structure will be passed to the function and updated when the function
returns.  Structures are packed according to the default alignment rules for
the platform's native C <code>struct</code>s.  

<h4>Array-of-Structure Arguments</h4>
To pass an array of structures, simply use a Java array of the desired
structure type.  If the array is uninitialized, it will be auto-initialized
prior to the function call.<p>
<blockquote><code><pre>
// C code
void get_devices(struct Device[], int size);

// Java
int size = ...
Device[] devices = new Device[size];
lib.get_devices(devices, devices.length);
</pre></code></blockquote>

Alternatively, you can reallocate a single Structure instance into an array as
follows:<br>
<blockquote><code><pre>
Device dev = new Device();
// As an array of Structure
Structure[] structs = dev.toArray(size);
// As an array of Device
Device[] devices = (Device[])dev.toArray(new Device[size]);
</pre></code></blockquote>

<h4>Returning an Array of <code>struct</code></h4>
Declare the method as returning a {@link com.sun.jna.Structure} of the
appropriate type, then invoke {@link com.sun.jna.Structure#toArray(int)} to
convert to an array of initialized structures of the appropriate size.  Note
that your {@link com.sun.jna.Structure} class must have a no-args constructor,
and you are responsible for freeing the returned memory if applicable in
whatever way is appropriate for the called function.<p>
<blockquote><code><pre>
// C code
struct Display* get_displays(int* pcount);
void free_displays(struct Display* displays);

// Java
Display get_displays(InteByReference pcount);
void free_displays(Display[] displays);
...
IntByReference pcount = new IntByReference();
Display d = lib.get_displays(pcount);
Display[] displays = (Display[])d.toArray(new Display[pcount.getValue()]);
...
lib.free_displays(displays);
</pre></code></blockquote>

<h4>Nested Structure Definitions</h4>
Nested structures are treated as consecutive memory (as opposed to pointers to
structures).  For example:<br>
<blockquote><code><pre>
// C code
typedef struct _Point {
  int x, y;
} Point;

typedef struct _Line {
  Point start;
  Point end;
} Line;

// JNA code
class Point extends Structure {
  public int x, y;
}

class Line extends Structure {
  public Point start;
  public Point end;
}
</pre></code></blockquote>

Explicit initialization of nested structures is not required; the objects will
be created as needed and properly mapped to the parent structure's memory.<p>

If you need a pointer to a structure (or more generally, a pointer to a buffer), do this instead:<br>

<blockquote><code><pre>
// C code
typedef struct _Line2 {
  Point* p1;
  Point* p2;
} Line2;

// JNA code
class Line2 extends Structure {
  public Pointer p1;
  public Pointer p2;
}

Line2 line2;
Point p1, p2;
...
line2.p1 = p1.getPointer();
line2.p2 = p2.getPointer();
</pre></code></blockquote>

<h4>Nested arrays</h4>
Structures with nested arrays require an explicit constructor to ensure the
structure size is properly calculated.
<blockquote><code><pre>
typedef struct _Buffer {
  char buf1[32];
  char buf2[1024];
} Buffer;

class Buffer extends Structure {
  public byte[] buf1 = new byte[32];
  public byte[] buf2 = new byte[1024];
}
</pre></code></blockquote>

Calculation of the native size of the structure is deferred until the
structure is actually used.

<h4>Variable-sized structures</h4>
Structures with variable size, or with primitive array elements, for example:<br>
<blockquote><code><pre>
// C code
typedef struct _Header {
  int flags;
  int buf_length;
  char buffer[1];
} Header;
</pre></code></blockquote>

require a constructor which establishes the required size for the structure
and initializes things appropriately.  For example:<br>

<blockquote><code><pre>
// JNA code
class Header extends Structure {
  public int flags;
  public int buf_length;
  public byte[] buffer;
  public Header(int bufferSize) {
    buffer = new byte[bufferSize];
    buf_length = buffer.length;
    allocateMemory();
  }
}
</pre></code></blockquote>

<h4>Volatile fields</h4>
Normally, JNA will write the entire contents of a <code>Structure</code> prior
to a function call and read back from native memory after the function call.
Sometimes a structure field is not intended for client use, gets modified
asynchronously by hardware, or otherwise is effectively read-only.
If you expect any fields of the structure to be modified by any agent outside
your Java program, you should mark the field <code>volatile</code>.  This
prevents JNA from automatically updating the native memory from the Java
value.  You can still force an update of the native memory from the Java value
by calling {@link com.sun.jna.Structure#writeField(String)} for the field in
question. 
<blockquote><code><pre>
// JNA code
class Data extends Structure {
  public volatile int refCount; 
  public int value;
}
...
Data data = new Data();
</pre></code></blockquote>
In the above example, the field <code>refCount</code> will only be updated
based on the Java value with a call to
<code>data.writeField("refCount")</code>.  To obtain the current state of
native memory, call {@link com.sun.jna.Structure#read()} (to update the entire
structure) or {@link com.sun.jna.Structure#readField(String)
data.readField("refCount")} (to update just the <code>refCount</code> field). 

<h3>Unions</h3>
Unions are a special type of Structure.  Each declared field within the union
overlays the same address in native memory.  When writing a union to native
memory, you <em>must</em> specify which field is to be written by supplying
the desired field's class to the {@link com.sun.jna.Union#setType}
method.  On read, all non-pointer-based fields will be initialized from native
memory.  Structure, String, and WString members will <em>not</em> be
initialized unless they are selected via {@link com.sun.jna.Union#setType}.

<h3>Java Object arguments</h3>
In some cases, it would seem convenient to pass a Java object as an opaque
pointer for later use by a Java callback method.  Unfortunately, this proves
problematic in that the native code must become responsible for reference
tracking.   Until a consistent method or methods of handling these situations
is formulated, passing Java objects directly is not supported.

<a name="crash-protection"/>
<h2>VM Crash Protection</h2>
When defining a new library and writing tests for it, it not uncommon to encounter memory access errors which crash the VM.  These are often caused by improper mappings or invalid arguments passed to the native library.  To generate Java errors instead of crashing the VM, call {@link com.sun.jna.Native#setProtected Native.setProtected(true)}</code>.

</body>
</html>

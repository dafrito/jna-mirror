<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN">
<html>
<head>
<!-- 
  Copyright 2007 Timothy Wall
-->
</head>

<HR>
<CENTER>
<H1>Java Native Access</H1>
</CENTER>
<body bgcolor="white">
This document is the API specification for the
<a href=http://jna.dev.java.net>JNA</a>
library for simplified native library access for Java.
<p>
<a href=#navbar_top>Top</a>&nbsp;
<a href=http://jna.dev.java.net>JNA Home</a>&nbsp;
<a href=index.html target=_top>API w/FRAMES</a>&nbsp;
<p>

<h1>Java Native Access (JNA)</h1>
JNA provides simplified access to native library methods without requiring any
additional JNI or native code.
<p>

<h2>Library Mapping</h2>
When you've determined which shared library holds the methods to which you
need access, create an interface class corresponding to that library.  For
example, a mapping for the C library itself would look like this:<br>
<code><pre>
public interface CLibrary extends Library {
    CLibrary INSTANCE = (CLibrary)Native.loadLibrary("c", CLibrary.class);
}
</pre></code>
The <code>String</code> passed to the <code>Native.loadLibrary</code> method
is the undecorated name of the shared library file.  Here are some examples of
library name mappings.  To make sure you've correctly mapped the name, you can
double-check that <code>System.mapLibraryName</code> returns the name of the
library file.
<table>
<tr><td><b>OS</b></td><td><b>Library Name</b></td><td><b>String</b></td></tr>
<tr><td>Windows</td><td>user32.dll</td><td>user32</td></tr>
<tr><td>Linux</td><td>libX11.so</td><td>X11</td></tr>
<tr><td>Mac OS X</td><td>libm.dylib</td><td>m</td></tr>
</table>

<h2>Function Mapping</h2>
Function names are mapped directly from their Java interface name to the
symbol exported by the native library.  For instance, the function to convert
an ASCII string into an integer would look like this:<br>
<code><pre>
public interface CLibrary extends Library {
    int atol(String s);
}
</pre></code>
If you prefer to rename the Java methods to conform to Java coding
conventions, then you can provide a <code>Map</code> to
<code>Native.loadLibrary</code> which maps the Java names to the native
names.  While this keeps your Java code a little cleaner, the additional
mapping of names may make a little less obvious the native functions being called.

<h2>Function Argument Mapping (Java to Native Type Conversions, or Marshalling/Unmarshalling)</h2>
Java types are chosen to match native types of the same size.  These are the
default type mappings:<br>
<table>
<tr><td><b>Native Type</b></td><td><b>Java Type</b></td></tr>
<tr><td>char</td><td>byte</td>
<tr><td>char*</td><td>String</td>
<tr><td>wchar_t</td><td>char</td>
<tr><td>wchar_t*</td><td>{@link com.sun.jna.WString}</td>
<tr><td>short</td><td>short</td>
<tr><td>long</td><td>int</td>
<tr><td>long long</td><td>long</td>
<tr><td>float</td><td>float</td>
<tr><td>double</td><td>double</td>
<tr><td>pointer (to type or array as pointer)</td><td>{@link com.sun.jna.Pointer}</td>
<tr><td>nested arrays</td><td>Array of type</td>
<tr><td>nested structures</td><td>{@link com.sun.jna.Structure}</td>
<tr><td><i>not yet implemented</i></td>
<tr><td>unions</td>
<tr><td>bitfields</td>
</table>
<p>

<h3>Pointers</h3>
Pointers may be used as an opaque type from which other data types may be
extracted.  The user is generally not allowed to construct a Pointer de novo.

<h3>Strings</h3>
Java <code>String</code>s perform the same function as the native types
<code>const char*</code> and <code>const wchar_t*</code>
(<code>NUL</code>-terminated arrays).  In order to use the proper type when
calling a native function, we have to introduce some sort of annotation to
identify how the java  <code>String</code> should be converted.

Java <code>String</code>s are automatically converted to <code>char*</code>
since this is the most common usage of strings.  Strings are automatically
converted to a <code>NUL</code>-terminated array of <code>char</code> across
the function call.  Returned <code>char*</code> values are automatically
copied into a <code>String</code> if the method signature returns
<code>String</code> (<code>strdup</code>, for example).
<p>
If the native method returns char* and actually allocates
memory, a return type of {@link com.sun.jna.Pointer} should be used to avoid
leaking the memory.  It is then up to you to take the necessary steps to free
the allocated memory.
<p>

<h3>Wide Strings</h3>
The {@link com.sun.jna.WString} class is used to identify wide character
strings, and only requires a little effort to obtain a
<code>String</code>.  
<p>
While it would be possible to identify wide string arguments by tagging the
strings themselves (for example, with a special prefix like "\u0000W\u0000"),
that method can't be used to identify wide string return values.  So for
consistency, the {@link com.sun.jna.WString} type is used in both cases.

<h3>Buffers/Memory Blocks</h3>
Use arrays to represent buffers of primitive types.  A native method cannot
return a Java array, since there is no canonical way to indicate the intendend
length of the returned array.  Instead, use one of the array access methods in
the Pointer class, supplying the length of the returned array.

<h3>Structures</h3>

<h4>Pointer-to-Structure Arguments</h4>
To pass a pointer to a structure as an argument, simply use the Java structure
subclass, and a pointer to native data memory will be used.  The contents of
the structure will be passed to the function and updated when the function
returns.  Structures are packed according to the default alignment rules for
the platform's native C <code>struct</code>s.  

<h4>Nested Structure Definitions</h4>
Nested structures are treated as consecutive memory (as opposed to pointers to
structures).  For example:<br>
<code><pre>
// C code
typedef struct _Point {
  int x, y;
} Point;

typedef struct _Line {
  Point start;
  Point end;
} Line;

// JNA code
class Point extends Structure {
  public int x, y;
}

class Line extends Structure {
  public Point start;
  public Point end;
}
</pre></code>

Explicit initialization of nested structures is not required; the objects will
be created as needed and properly mapped to the parent structure's memory.<p>

If you need a pointer to a structure, do this instead:<br>

<code><pre>
// C code
typedef struct _Line2 {
  Point* p1;
  Point* p2;
} Line2;

// JNA code
class Line2 extends Structure {
  public Pointer p1;
  public Pointer p2;
}

Line2 line2;
Point p1, p2;
...
line2.p1 = p1.getPointer();
line2.p2 = p2.getPointer();
</pre></code>

<h4>Nested arrays</h4>
Structures with nested arrays require an explicit constructor to ensure the
structure size is properly calculated.
<code><pre>
typedef struct _Buffer {
  char buf1[32];
  char buf2[1024];
} Buffer;

class Buffer extends Structure {
  public byte[] buf1 = new byte[32];
  public byte[] buf2 = new byte[1024];
}
</pre></code>

Calculation of the native size of the structure is deferred until the
structure is actually used.

<h4>Variable-sized structures</h4>
Structures with variable size, for example:<br>
<code><pre>
// C code
typedef struct _Header {
  int flags;
  int buf_length;
  char buffer[1];
} Header;
</pre></code>

require a constructor which establishes the required size for the structure
and initializes things appropriately.  For example:<br>

<code><pre>
// JNA code
class Header extends Structure {
  public int flags;
  public int buf_length;
  public byte[] buffer;
  public Header(int bufferSize) {
    buffer = new byte[bufferSize];
    buf_length = buffer.length;
    allocateMemory();
  }
}
</pre></code>

<h3>Java Object arguments</h3>
In some cases, it would seem convenient to pass a Java object as an opaque
pointer for later use by a Java callback method.  Unfortunately, this proves
problematic in that the native code must become responsible for reference
tracking.   Until a consistent method or methods of handling these situations
is formulated, passing Java objects directly is not supported.

</body>
</html>
